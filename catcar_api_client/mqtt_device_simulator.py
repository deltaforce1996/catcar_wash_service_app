#!/usr/bin/env python3
"""
CatCar Wash Service - MQTT Device State Simulator
Simulator ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏à‡∏≥‡∏•‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á device state streaming ‡∏ú‡πà‡∏≤‡∏ô MQTT
‡∏ï‡∏≤‡∏° specification ‡πÉ‡∏ô PLAN-COMUNICATION.md
"""

import paho.mqtt.client as mqtt
import json
import time
import random
import threading
import signal
import sys
import yaml
import os
from datetime import datetime
from typing import Dict, List, Optional
from enum import Enum

class DeviceStatus(Enum):
    NORMAL = "NORMAL"
    ERROR = "ERROR"
    OFFLINE = "OFFLINE"

class MQTTDeviceSimulator:
    def __init__(self, broker_host: str = "localhost", broker_port: int = 1883):
        """
        Initialize MQTT Device Simulator
        
        Args:
            broker_host: MQTT broker host
            broker_port: MQTT broker port
        """
        self.broker_host = broker_host
        self.broker_port = broker_port
        self.devices: Dict[str, Dict] = {}
        self.running = False
        self.threads: List[threading.Thread] = []
        self.total_messages_sent = 0
        
        # Setup signal handlers for graceful shutdown
        signal.signal(signal.SIGINT, self._signal_handler)
        signal.signal(signal.SIGTERM, self._signal_handler)
    
    def _create_device_client(self, device_id: str) -> mqtt.Client:
        """Create MQTT client for a specific device"""
        client = mqtt.Client()
        client.on_connect = lambda c, u, f, rc: self._on_connect(c, device_id, rc)
        client.on_disconnect = lambda c, u, rc: self._on_disconnect(c, device_id, rc)
        client.on_publish = lambda c, u, mid: self._on_publish(c, device_id, mid)
        client.on_log = self._on_log
        return client
    
    def _on_connect(self, client, device_id, rc):
        """MQTT connection callback"""
        if rc == 0:
            print(f"‚úÖ Device {device_id} ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ MQTT broker ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à")
        else:
            print(f"‚ùå Device {device_id} ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ MQTT broker ‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à: {rc}")
    
    def _on_disconnect(self, client, device_id, rc):
        """MQTT disconnection callback"""
        if rc != 0:
            print(f"‚ö†Ô∏è  Device {device_id} MQTT broker disconnected: {rc}")
    
    def _on_publish(self, client, device_id, mid):
        """MQTT publish callback"""
        self.total_messages_sent += 1
    
    def _on_log(self, client, userdata, level, buf):
        """MQTT log callback (optional)"""
        # Uncomment for debug logging
        # print(f"MQTT Log: {buf}")
        pass
    
    def _signal_handler(self, signum, frame):
        """Handle shutdown signals"""
        print(f"\nüõë ‡∏£‡∏±‡∏ö‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì {signum} ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏õ‡∏¥‡∏î simulator...")
        self.stop()
        sys.exit(0)
    
    def connect_device(self, device_id: str) -> bool:
        """
        Connect a specific device to MQTT broker
        
        Args:
            device_id: Device identifier
            
        Returns:
            bool: True if connected successfully
        """
        if device_id not in self.devices:
            return False
        
        try:
            device = self.devices[device_id]
            
            # Check if client exists and is connected
            if ('client' in device and 
                device['client'] is not None and 
                device['client'].is_connected()):
                return True
            
            # Create new client for this device
            client = self._create_device_client(device_id)
            client.connect(self.broker_host, self.broker_port, 60)
            client.loop_start()
            
            # Wait for connection
            time.sleep(1)
            
            if client.is_connected():
                device['client'] = client
                return True
            else:
                client.loop_stop()
                client.disconnect()
                return False
                
        except Exception as e:
            print(f"‚ùå Device {device_id} ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ MQTT broker ‡πÑ‡∏î‡πâ: {e}")
            return False
    
    def disconnect_device(self, device_id: str):
        """Disconnect a specific device from MQTT broker"""
        if device_id in self.devices and 'client' in self.devices[device_id]:
            client = self.devices[device_id]['client']
            if client is not None and client.is_connected():
                client.loop_stop()
                client.disconnect()
            self.devices[device_id]['client'] = None
    
    def disconnect_all(self):
        """Disconnect all devices from MQTT broker"""
        for device_id in list(self.devices.keys()):
            self.disconnect_device(device_id)
        print("üîå ‡∏ï‡∏±‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ MQTT broker ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÅ‡∏•‡πâ‡∏ß")
    
    def add_device(self, device_id: str, status: DeviceStatus = DeviceStatus.NORMAL, silent: bool = False) -> bool:
        """
        Add a device to simulate
        
        Args:
            device_id: Device identifier
            status: Initial device status
            silent: If True, don't print success message (useful for bulk operations)
            
        Returns:
            bool: True if device added successfully
        """
        if device_id in self.devices:
            if not silent:
                print(f"‚ö†Ô∏è  Device {device_id} ‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß")
            return False
        
        self.devices[device_id] = {
            "status": status,
            "uptime": 0,  # minutes
            "message_count": 0,
            "start_time": time.time(),
            "last_rssi": random.randint(-90, -40),
            "client": None  # MQTT client for this device
        }
        
        if not silent:
            print(f"‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏° Device: {device_id} (Status: {status.value})")
        return True
    
    def remove_device(self, device_id: str) -> bool:
        """
        Remove a device from simulation
        
        Args:
            device_id: Device identifier
            
        Returns:
            bool: True if device removed successfully
        """
        if device_id not in self.devices:
            print(f"‚ö†Ô∏è  Device {device_id} ‡πÑ‡∏°‡πà‡∏û‡∏ö")
            return False
        
        # Disconnect device before removing
        self.disconnect_device(device_id)
        del self.devices[device_id]
        print(f"‚úÖ ‡∏•‡∏ö Device: {device_id}")
        return True
    
    def update_device_status(self, device_id: str, status: DeviceStatus) -> bool:
        """
        Update device status
        
        Args:
            device_id: Device identifier
            status: New device status
            
        Returns:
            bool: True if updated successfully
        """
        if device_id not in self.devices:
            print(f"‚ö†Ô∏è  Device {device_id} ‡πÑ‡∏°‡πà‡∏û‡∏ö")
            return False
        
        self.devices[device_id]["status"] = status
        print(f"‚úÖ ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó Device {device_id} Status: {status.value}")
        return True
    
    def _generate_device_payload(self, device_id: str) -> Dict:
        """
        Generate device state payload
        
        Args:
            device_id: Device identifier
            
        Returns:
            Dict: Device state payload
        """
        device = self.devices[device_id]
        
        # Update uptime (in minutes)
        device["uptime"] = int((time.time() - device["start_time"]) / 60)
        
        # Generate RSSI (slight variation from last value)
        last_rssi = device["last_rssi"]
        rssi_variation = random.randint(-5, 5)
        new_rssi = max(-90, min(-40, last_rssi + rssi_variation))
        device["last_rssi"] = new_rssi
        
        payload = {
            "rssi": new_rssi,
            "status": device["status"].value,
            "uptime": device["uptime"],
            "timestamp": int(time.time() * 1000)  # milliseconds
        }
        
        return payload
    
    def _device_streaming_thread(self, device_id: str, interval: int = 60):
        """
        Device streaming thread - sends state every interval seconds
        
        Args:
            device_id: Device identifier
            interval: Streaming interval in seconds
        """
        print(f"üöÄ ‡πÄ‡∏£‡∏¥‡πà‡∏° streaming ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Device: {device_id}")
        
        # Connect this device first
        if not self.connect_device(device_id):
            print(f"‚ùå ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ Device {device_id}")
            return
        
        while self.running and device_id in self.devices:
            try:
                device = self.devices[device_id]
                
                # Check if device client is connected
                if ('client' not in device or 
                    device['client'] is None or 
                    not device['client'].is_connected()):
                    print(f"‚ö†Ô∏è  Device {device_id} ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ ‡∏Å‡∏≥‡∏•‡∏±‡∏á reconnect...")
                    if not self.connect_device(device_id):
                        time.sleep(5)
                        continue
                
                # Generate and send payload
                payload = self._generate_device_payload(device_id)
                topic = f"server/{device_id}/streaming"
                
                # Publish to MQTT using device's own client
                if device['client'] is None:
                    print(f"‚ùå Device {device_id} client is None")
                    continue
                    
                result = device['client'].publish(topic, json.dumps(payload), qos=1)
                
                if result.rc == mqtt.MQTT_ERR_SUCCESS:
                    device["message_count"] += 1
                    timestamp = datetime.now().strftime("%H:%M:%S")
                    print(f"[{timestamp}] üì° {device_id}: RSSI={payload['rssi']}dBm, "
                          f"Status={payload['status']}, Uptime={payload['uptime']}min")
                else:
                    print(f"‚ùå ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• {device_id} ‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à: {result.rc}")
                
                # Wait for next interval
                time.sleep(interval)
                
            except Exception as e:
                print(f"‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô thread {device_id}: {e}")
                time.sleep(5)  # Wait before retry
        
        print(f"üõë ‡∏´‡∏¢‡∏∏‡∏î streaming ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Device: {device_id}")
    
    def start(self, interval: int = 60):
        """
        Start device simulation
        
        Args:
            interval: Streaming interval in seconds (default: 60)
        """
        if self.running:
            print("‚ö†Ô∏è  Simulator ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß")
            return
        
        if not self.devices:
            print("‚ùå ‡πÑ‡∏°‡πà‡∏°‡∏µ device ‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏à‡∏≥‡∏•‡∏≠‡∏á ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏û‡∏¥‡πà‡∏° device ‡∏Å‡πà‡∏≠‡∏ô")
            return
        
        # Check if any devices are connected
        connected_devices = 0
        for device_id in self.devices:
            if self.connect_device(device_id):
                connected_devices += 1
        
        if connected_devices == 0:
            print("‚ùå ‡πÑ‡∏°‡πà‡∏°‡∏µ device ‡∏ó‡∏µ‡πà‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ MQTT broker ‡πÑ‡∏î‡πâ")
            return
        
        self.running = True
        self.threads = []
        
        print(f"üöÄ ‡πÄ‡∏£‡∏¥‡πà‡∏° Device Simulation ({len(self.devices)} devices, interval: {interval}s)")
        print("=" * 60)
        
        # Start thread for each device
        for device_id in self.devices:
            thread = threading.Thread(
                target=self._device_streaming_thread,
                args=(device_id, interval),
                daemon=True
            )
            thread.start()
            self.threads.append(thread)
        
        print("‚úÖ ‡πÄ‡∏£‡∏¥‡πà‡∏° Simulation ‡πÅ‡∏•‡πâ‡∏ß! ‡∏Å‡∏î Ctrl+C ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏´‡∏¢‡∏∏‡∏î")
    
    def stop(self):
        """Stop device simulation"""
        if not self.running:
            print("‚ö†Ô∏è  Simulator ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏≠‡∏¢‡∏π‡πà")
            return
        
        print("\nüõë ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏´‡∏¢‡∏∏‡∏î Simulation...")
        self.running = False
        
        # Wait for threads to finish
        for thread in self.threads:
            thread.join(timeout=5)
        
        self.threads = []
        
        # Disconnect all devices
        self.disconnect_all()
        print("‚úÖ ‡∏´‡∏¢‡∏∏‡∏î Simulation ‡πÅ‡∏•‡πâ‡∏ß")
    
    def get_statistics(self) -> Dict:
        """
        Get simulation statistics
        
        Returns:
            Dict: Statistics information
        """
        total_device_messages = sum(device["message_count"] for device in self.devices.values())
        
        stats = {
            "total_devices": len(self.devices),
            "running": self.running,
            "total_messages_sent": self.total_messages_sent,
            "device_messages": {device_id: device["message_count"] 
                               for device_id, device in self.devices.items()},
            "uptime": {device_id: device["uptime"] 
                      for device_id, device in self.devices.items()}
        }
        
        return stats
    
    def show_statistics(self):
        """Display simulation statistics"""
        stats = self.get_statistics()
        
        print("\nüìä Simulation Statistics")
        print("=" * 40)
        print(f"üî¢ ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô Devices: {stats['total_devices']}")
        print(f"üîÑ ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞: {'‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ó‡∏≥‡∏á‡∏≤‡∏ô' if stats['running'] else '‡∏´‡∏¢‡∏∏‡∏î‡πÅ‡∏•‡πâ‡∏ß'}")
        print(f"üì° ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô Messages ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î: {stats['total_messages_sent']}")
        print("\nüìã ‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î Device:")
        
        for device_id in stats['device_messages']:
            messages = stats['device_messages'][device_id]
            uptime = stats['uptime'][device_id]
            status = self.devices[device_id]['status'].value
            connected = "üü¢" if ('client' in self.devices[device_id] and 
                                self.devices[device_id]['client'] is not None and 
                                self.devices[device_id]['client'].is_connected()) else "üî¥"
            print(f"  ‚Ä¢ {device_id}: {messages} messages, {uptime}min uptime, Status: {status} {connected}")

def load_docker_compose_config() -> tuple:
    """
    Load MQTT configuration from docker-compose.develop.yml
    
    Returns:
        tuple: (broker_host, broker_port)
    """
    try:
        # Try to read docker-compose file
        compose_path = "../docker-compose.develop.yml"
        if not os.path.exists(compose_path):
            compose_path = "./docker-compose.develop.yml"
        
        if os.path.exists(compose_path):
            with open(compose_path, 'r', encoding='utf-8') as f:
                compose_data = yaml.safe_load(f)
            
            # Extract EMQX configuration
            if 'services' in compose_data and 'emqx' in compose_data['services']:
                emqx_config = compose_data['services']['emqx']
                ports = emqx_config.get('ports', [])
                
                # Find port 1883 mapping
                for port_mapping in ports:
                    if '1883:1883' in port_mapping:
                        return "localhost", 1883
                
                print("‚ö†Ô∏è  ‡πÑ‡∏°‡πà‡∏û‡∏ö port 1883 ‡πÉ‡∏ô docker-compose")
        
        print("‚ö†Ô∏è  ‡πÑ‡∏°‡πà‡∏û‡∏ö docker-compose.develop.yml ‡πÉ‡∏ä‡πâ‡∏Ñ‡πà‡∏≤ default")
        return "localhost", 1883
        
    except Exception as e:
        print(f"‚ö†Ô∏è  ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏≠‡πà‡∏≤‡∏ô docker-compose ‡πÑ‡∏î‡πâ: {e} ‡πÉ‡∏ä‡πâ‡∏Ñ‡πà‡∏≤ default")
        return "localhost", 1883

def generate_device_id() -> str:
    """Generate a random device ID"""
    return f"device-{random.randint(1000, 9999)}"

def generate_multiple_device_ids(count: int) -> List[str]:
    """Generate multiple unique device IDs"""
    device_ids = set()
    while len(device_ids) < count:
        device_id = generate_device_id()
        device_ids.add(device_id)
    return list(device_ids)

def show_menu():
    """Display main menu"""
    print("\n" + "=" * 60)
    print("üöó CatCar Wash Service - MQTT Device State Simulator")
    print("=" * 60)
    print("üìã ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á:")
    print("1. ‚ûï ‡πÄ‡∏û‡∏¥‡πà‡∏° Device")
    print("2. ‚ûñ ‡∏•‡∏ö Device")
    print("3. üîÑ ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô Device Status")
    print("4. üé≤ ‡πÄ‡∏û‡∏¥‡πà‡∏° 100 Devices (Random Status)")
    print("5. üöÄ ‡πÄ‡∏£‡∏¥‡πà‡∏° Simulation")
    print("6. üõë ‡∏´‡∏¢‡∏∏‡∏î Simulation")
    print("7. üìä ‡∏î‡∏π‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥")
    print("8. üìã ‡∏î‡∏π‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ Devices")
    print("9. ‚ùå ‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°")
    print("=" * 60)

def handle_add_device(simulator: MQTTDeviceSimulator):
    """Handle add device command"""
    print("\n‚ûï ‡πÄ‡∏û‡∏¥‡πà‡∏° Device")
    print("-" * 30)
    
    device_id = input("üÜî Device ID (Enter ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö auto-generate): ").strip()
    if not device_id:
        device_id = generate_device_id()
        print(f"üé≤ ‡∏™‡∏£‡πâ‡∏≤‡∏á Device ID ‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥: {device_id}")
    
    print("\nüìä ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å Status:")
    print("1. NORMAL")
    print("2. ERROR") 
    print("3. OFFLINE")
    
    status_choice = input("üëâ ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å (1-3, default: 1): ").strip()
    status_map = {
        "1": DeviceStatus.NORMAL,
        "2": DeviceStatus.ERROR,
        "3": DeviceStatus.OFFLINE
    }
    status = status_map.get(status_choice, DeviceStatus.NORMAL)
    
    simulator.add_device(device_id, status)

def handle_remove_device(simulator: MQTTDeviceSimulator):
    """Handle remove device command"""
    print("\n‚ûñ ‡∏•‡∏ö Device")
    print("-" * 30)
    
    if not simulator.devices:
        print("‚ùå ‡πÑ‡∏°‡πà‡∏°‡∏µ device ‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏•‡∏ö")
        return
    
    print("üìã Devices ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà:")
    for i, device_id in enumerate(simulator.devices.keys(), 1):
        print(f"{i}. {device_id}")
    
    device_id = input("üÜî Device ID ‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏•‡∏ö: ").strip()
    simulator.remove_device(device_id)

def handle_change_status(simulator: MQTTDeviceSimulator):
    """Handle change device status command"""
    print("\nüîÑ ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô Device Status")
    print("-" * 30)
    
    if not simulator.devices:
        print("‚ùå ‡πÑ‡∏°‡πà‡∏°‡∏µ device")
        return
    
    print("üìã Devices ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà:")
    for i, device_id in enumerate(simulator.devices.keys(), 1):
        current_status = simulator.devices[device_id]['status'].value
        print(f"{i}. {device_id} (Status: {current_status})")
    
    device_id = input("üÜî Device ID: ").strip()
    if device_id not in simulator.devices:
        print("‚ùå ‡πÑ‡∏°‡πà‡∏û‡∏ö Device ID")
        return
    
    print("\nüìä ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å Status ‡πÉ‡∏´‡∏°‡πà:")
    print("1. NORMAL")
    print("2. ERROR")
    print("3. OFFLINE")
    
    status_choice = input("üëâ ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å (1-3): ").strip()
    status_map = {
        "1": DeviceStatus.NORMAL,
        "2": DeviceStatus.ERROR,
        "3": DeviceStatus.OFFLINE
    }
    
    if status_choice in status_map:
        simulator.update_device_status(device_id, status_map[status_choice])
    else:
        print("‚ùå ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á")

def handle_add_random_devices(simulator: MQTTDeviceSimulator):
    """Handle add 100 random devices command"""
    print("\nüé≤ ‡πÄ‡∏û‡∏¥‡πà‡∏° 100 Devices (Random Status)")
    print("-" * 40)
    
    try:
        # ‡∏™‡∏£‡πâ‡∏≤‡∏á 100 device IDs ‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏ã‡πâ‡∏≥‡∏Å‡∏±‡∏ô
        device_ids = generate_multiple_device_ids(100)
        
        print(f"üîÑ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á {len(device_ids)} devices...")
        
        success_count = 0
        failed_count = 0
        
        for i, device_id in enumerate(device_ids, 1):
            # ‡∏™‡∏∏‡πà‡∏° status
            random_status = random.choice(list(DeviceStatus))
            
            # ‡πÄ‡∏û‡∏¥‡πà‡∏° device (silent mode ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πà‡πÉ‡∏´‡πâ‡πÅ‡∏™‡∏î‡∏á message ‡∏°‡∏≤‡∏Å‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ)
            if simulator.add_device(device_id, random_status, silent=True):
                success_count += 1
            else:
                failed_count += 1
            
            # ‡πÅ‡∏™‡∏î‡∏á progress ‡∏ó‡∏∏‡∏Å 10 devices
            if i % 10 == 0:
                print(f"üìä Progress: {i}/100 devices processed...")
        
        print(f"\n‚úÖ ‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô!")
        print(f"üìà ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à: {success_count} devices")
        print(f"‚ùå ‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß: {failed_count} devices")
        print(f"üìä ‡∏£‡∏ß‡∏°: {len(simulator.devices)} devices ‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö")
        
    except Exception as e:
        print(f"‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: {e}")

def handle_start_simulation(simulator: MQTTDeviceSimulator):
    """Handle start simulation command"""
    print("\nüöÄ ‡πÄ‡∏£‡∏¥‡πà‡∏° Simulation")
    print("-" * 30)
    
    if not simulator.devices:
        print("‚ùå ‡πÑ‡∏°‡πà‡∏°‡∏µ device ‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏à‡∏≥‡∏•‡∏≠‡∏á")
        return
    
    try:
        interval = int(input("‚è±Ô∏è  Interval (‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ, default: 60): ").strip() or "60")
        if interval < 1:
            interval = 60
    except ValueError:
        interval = 60
    
    simulator.start(interval)

def handle_stop_simulation(simulator: MQTTDeviceSimulator):
    """Handle stop simulation command"""
    print("\nüõë ‡∏´‡∏¢‡∏∏‡∏î Simulation")
    print("-" * 30)
    simulator.stop()

def handle_show_statistics(simulator: MQTTDeviceSimulator):
    """Handle show statistics command"""
    simulator.show_statistics()

def handle_list_devices(simulator: MQTTDeviceSimulator):
    """Handle list devices command"""
    print("\nüìã ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ Devices")
    print("-" * 30)
    
    if not simulator.devices:
        print("‚ùå ‡πÑ‡∏°‡πà‡∏°‡∏µ device")
        return
    
    for device_id, device in simulator.devices.items():
        status = device['status'].value
        uptime = device['uptime']
        messages = device['message_count']
        connected = "üü¢ Connected" if ('client' in device and device['client'] is not None and device['client'].is_connected()) else "üî¥ Disconnected"
        print(f"üÜî {device_id}")
        print(f"   Status: {status}")
        print(f"   Uptime: {uptime} minutes")
        print(f"   Messages: {messages}")
        print(f"   Connection: {connected}")
        print()

def main():
    """Main function"""
    print("üöó CatCar Wash Service - MQTT Device State Simulator")
    print("=" * 60)
    
    # Load MQTT configuration
    broker_host, broker_port = load_docker_compose_config()
    print(f"üîó MQTT Broker: {broker_host}:{broker_port}")
    
    # Initialize simulator
    simulator = MQTTDeviceSimulator(broker_host, broker_port)
    
    # Test MQTT broker connection (no need to connect all devices yet)
    print("üîó MQTT Broker configuration loaded")
    print("üí° Devices ‡∏à‡∏∞‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ MQTT broker ‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏¥‡πà‡∏° simulation")
    
    try:
        while True:
            show_menu()
            choice = input("üëâ ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á (1-9): ").strip()
            
            if choice == "1":
                handle_add_device(simulator)
            elif choice == "2":
                handle_remove_device(simulator)
            elif choice == "3":
                handle_change_status(simulator)
            elif choice == "4":
                handle_add_random_devices(simulator)
            elif choice == "5":
                handle_start_simulation(simulator)
            elif choice == "6":
                handle_stop_simulation(simulator)
            elif choice == "7":
                handle_show_statistics(simulator)
            elif choice == "8":
                handle_list_devices(simulator)
            elif choice == "9":
                print("üëã ‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°")
                break
            else:
                print("‚ùå ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏•‡∏Ç 1-9")
            
            # Pause before showing menu again (except for simulation running)
            if choice not in ["5", "6"] and not simulator.running:
                input("\n‚è∏Ô∏è  ‡∏Å‡∏î Enter ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡πÄ‡∏°‡∏ô‡∏π‡∏´‡∏•‡∏±‡∏Å...")
    
    except KeyboardInterrupt:
        print("\n\nüëã ‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°")
    finally:
        simulator.stop()
        simulator.disconnect_all()

if __name__ == "__main__":
    main()
